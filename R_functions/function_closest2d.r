
###
## Three functions to return x,y coordinate from an array which is nearest to a provided lat / long value
## Each function makes a differing assumption around the dimensions of the location information
###

# This function is based on an original Matlab function development by A. A. Bloom (UoE, now at the Jet Propulsion Laboratory).
# Translation to R and subsequent modifications by T. L Smallman (t.l.smallman@ed.ac.uk, UoE).

# Function assumes lat / long information at 1d arrays
closest2d_1 <- function (id,lat,long,lat_in,long_in) {

    # extract needed lat / long
    lat1 = lat_in[id] ; long1 = long_in[id]
    # calculate the distance between two points by Spherical law of the cosine
    # mean radius of earth in km
    R = 6371  # 6378137 m (R source equitorial)
    # convert degrees to radians
    deg_to_rad = 0.01745329 #pi/180
    # check lat long system
    if (length(which(as.vector(long) > 180)) > 1) {stop("Input error closest2d: longitude should be -180 to +180")}

  	## lat long are in single vectors repeating i.e. lat[1:10]=89.9,89.9,89.9... ; long[1:10]=-180,-160,-140....
  	# loop through to find the smallest distance
  	d_old = 1e6
  	# check for locations which exactly coincide, complete calculation and finally remove NaN generated by value "1"
    lat_deg_to_rad=as.vector(lat)*deg_to_rad ; long_deg_to_rad=as.vector(long)*deg_to_rad
  	d = sin(lat1*deg_to_rad)*sin(lat_deg_to_rad)+cos(lat1*deg_to_rad)*cos(lat_deg_to_rad)*cos(long_deg_to_rad-(long1*deg_to_rad))
  	d = acos(d)*R ; d[is.na(d)] = 0
  	output = which(d == min(d, na.rm=TRUE))[1] ; d_old = d[output]
  	#if (d_old > 10) {print(paste("id = ",id," Minimum distance found (",round(d_old,digits=1),") is greater than 10 km from actual location"))}
  	rm(d_old)

    # clean up
    rm(d,R,lat1,long1) # ; gc() ; gc()
    # return to the user
    return(output)

} # end of function

## Use byte compile
closest2d_1<-cmpfun(closest2d_1)

## Function assumes that lat / long are in 2d arrays which co-vary
closest2d_2 <- function (id,lat,long,lat_in,long_in) {

    # extract needed lat / long
    lat1 = lat_in[id] ; long1 = long_in[id]
    # calculate the distance between two points by Spherical law of the cosine
    # mean radius of earth in km
    R = 6371  # 6378137 m (R source equitorial)
    # convert degrees to radians
    deg_to_rad = 0.01745329 #pi/180
    # check lat long system
    if (length(which(as.vector(long) > 180)) > 1) {stop("Input error closest2d: longitude should be -180 to +180")}

    ## lat and long are in two - dimensional arrays which co-varying
    # loop through to find the smallest distance
    lat_deg_to_rad=as.vector(lat)*deg_to_rad ; long_deg_to_rad=as.vector(long)*deg_to_rad
    d = sin(lat1*deg_to_rad)*sin(lat_deg_to_rad)+cos(lat1*deg_to_rad)*cos(lat_deg_to_rad)*cos(long_deg_to_rad-(long1*deg_to_rad))
    # check for locations which exactly coincide, complete calculation and finally remove NaN generated by value "1"
    d = acos(d)*R ; d[is.na(d)] = 0
    #if (min(d) > 10) {print(paste("id = ",id," Minimum distance found (",round(min(d),digits=1),") is greater than 10 km from actual location"))}
    # Track location of the minimum distance
    d_loc = which(d == min(d))
    # Determine the i dimension location.
    # Ceiling forces rounding up before numerically secure minus 1 to keep things in bound at either end
    i = d_loc - (  (ceiling(d_loc/dim(lat)[1]) - 1) * dim(lat)[1] )
    # Determine the j dimension
    j = ceiling(d_loc / dim(lat)[1])
    # Prepare output and tidy
    output = list(i[1],j[1]) ; rm(i,j)

    # clean up
    rm(d,R,lat1,long1) # ; gc() ; gc()
    # return to the user
    return(output)

} # end of function

## Use byte compile
closest2d_2<-cmpfun(closest2d_2)

# Function assumes that lat / long are in 1 d array but that the vectors co-vary as in a 2d cartesian co-ordinates
closest2d_3 <- function (id,lat,long,lat_in,long_in) {

    # extract needed lat / long
    lat1 = lat_in[id] ; long1 = long_in[id]
    # calculate the distance between two points by Spherical law of the cosine
    # mean radius of earth in km
    R = 6371  # 6378137 m (R source equitorial)
    # convert degrees to radians
    deg_to_rad = 0.01745329 #pi/180
    # check lat long system
    if (length(which(as.vector(long) > 180)) > 1) {stop("Input error closest2d: longitude should be -180 to +180")}

  	## lat and long are in two 1-dimensional vectors but co-varying as in cartesian co-ordinates
  	# loop through to find the smallest distance
  	d_old=1e6
  	for (j in seq(1, length(lat))) {
   	    # convert all to radians
   	    d = acos(sin(lat1*deg_to_rad)*sin(lat[j]*deg_to_rad)+cos(lat1*deg_to_rad)*cos(lat[j]*deg_to_rad)*cos((long*deg_to_rad)-(long1*deg_to_rad)))*R
        if (is.na(min(d))) {d[is.na(d)] = 0}
      	    if (min(d) < d_old) {
              	possible_i = which(d == min(d))
              	if (length(possible_i) > 1 & possible_i[1] == 1 & possible_i[length(possible_i)] == length(long)) {
              	    possible_i = possible_i[which(long[possible_i] == long1)]
              	}
              	output = list(possible_i[1],j) ; d_old=min(d)
      	    } # min(d) < d_old
  	} # j loop
    #if (d_old > 10) {print(paste("id = ",id," Minimum distance found (",round(d_old,digits=1),") is greater than 10 km from actual location"))}
    rm(d_old)

    # clean up
    rm(d,R,lat1,long1) # ; gc() ; gc()
    # return to the user
    return(output)

} # end of function

## Use byte compile
closest2d_3<-cmpfun(closest2d_3)
